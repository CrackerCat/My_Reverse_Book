# 0. 内容约定

太长不看：真传一句话，假传万卷书。所以这个系列的废话特别多！

## 目标读者

这一系列的文章目标读者是谁：

已经有简单基础的逆向爱好者，不满足与拿到二进制就F5，想大概知道逆向工具内部原理，了解如何将汇编/字节码转换为伪代码，提升一些常识性知识，方便用于平时的工作生活。

有编写逆向工具、逆向插件、混淆对抗；或者优化现有的反编译器，比如，让现有逆向工具支持新的指令集架构、新的可执行文件格式、新的语言等等需求。

大晚上睡不着，没事干，就要找点事情干干的（比如我！）

## 文章约定

如果可以，这一系类的文章尽量使用并分析业界当前的最佳商用实践与开源工具

由于反编译技术由多个模块组成，其中的大多数难题目前是没有最优解的，因此后续的所有的章节将使用以下的结构

1、简要描述这一章节要说啥组件

2、说明这个组件属于整个反编译流程中的哪个部分

3、说明这一章节所解决的难题，提供正向与反向的示例

4、如果有必要，说明并提供示例，解释编译器将C代码编译成二进制的过程中做了什么优化；因此反编译器需要做对应的”反优化”提供可读性。

5、详细描述当前这一技术在IDA或者Ghidra等工具上的具体实现，提供示例

6、当前已有的实现存在什么缺陷？无法解决什么场景？使用源码举例为什么会出现这个场景。有没有更好的技术解决。逆向的工作中遇到了应该怎么办。

7、拓展话题，包括相关的静态分析对抗技术，我觉得有趣的东西等等。

8、学术相关，讨论学术界再这方便的研究历史与最新进展，但是学术界的东西通常晦涩难懂，上来就给你什么定理什么公式，我看着就头疼；因此这部分的部分内容可能要后续再补充了。

接着为了避免歧义，提前明确一些可能存在歧义的部分。

0、文章中所讨论的反汇编技术，默认目标都是正常编译的代码；不考虑加固、混淆、壳、等等不正常的东西，这部分的讨论都会在有独立的章节进行说明。

1、代码编译的目标指令集架构，默认是linux的x86\_64架构，且汇编的格式使用intel格式，我使用WSL-ubuntu编译

2、如果没有明确说明。编译器参数默认只启用-O3

3、文章里反编译器用的是IDA7.5及以上版本的工具进行反编译，如果大家需要这个工具可以找我或者去github上自行寻找学习版。

4、如果没有明确说明。文章中出现的 “常用的反编译工具”、“现在的反编译器” 这类语句中所说的反编译器，就是指IDA和Ghidra这两个最常用的软件
