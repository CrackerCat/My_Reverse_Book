# 反混淆：字符串加密

## 通用的字符串加密对抗

字符串加密有很多种小情况：解密的方式，什么时候解密，解密数据放到哪里。。。

但是总的来说，通用的方法有这么几种。

* Dump内存：对于将大多数的解密逻辑都放在初始化的逻辑中（比如JNI\_Onload 或者 init\_func），程序执行后dump内存是一种很棒的方法。但是，现在稍微复杂一定的混淆都会变成执行函数时解密，这就使得dump内存的方法不那么好用了。
* 模拟执行：模拟执行也是很通用的方法，通常用于对抗将字符串解密放到函数开头的场景。
*



还有一些技巧，比如在IDA中，我们可以将\_\_DATA段设置为只读的，这样IDA通过常量计算优化的能力，

## 独立的字符串解密函数

比较早期的字符串加密方案，将字符串全部加密存储后在使用时调用解密函数解密。

分析解密函数的逻辑后，通过XREF找到所有的调用点，分析传入的参数就能很容易的写出解密逻辑。

但是这里面可能会遇到一些小问题：

* 如何获得传入的参数：
* 解密的结果是动态分配的内存：

## 解密逻辑在每个函数头部

最常见的字符串加密，我通常使用模拟执行对抗。执行到原子写入为止。



## 解密逻辑在支配树父节点

可以说是上面的升级版本，这个方案会使得字符串加密逻辑更加的复杂，更加的细碎。

它的原理是由于支配树的父节点是执行当前basic-block的必经节点，因此只要将当前使用的字符串解密逻辑放到它的父节点里面去，就确保了解密逻辑一定执行。

我没有找到比较合适的案例，因此这部分不再展开了，依照上面的思路应该是能够完成一个较为通用的方案。



## 混合其他混淆的字符串加密

还有一个点不得不说，字符串加密通常不单独出现，最典型的场景是和OLLVM一起出现。这回导致逻辑更加的难看懂。
